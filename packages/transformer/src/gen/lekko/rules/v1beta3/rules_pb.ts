// Copyright 2022 Lekko Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file lekko/rules/v1beta3/rules.proto (package lekko.rules.v1beta3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Value } from "@bufbuild/protobuf";

/**
 * @generated from enum lekko.rules.v1beta3.ComparisonOperator
 */
export enum ComparisonOperator {
  /**
   * @generated from enum value: COMPARISON_OPERATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * == only applies to number, string and bool values.
   *
   * @generated from enum value: COMPARISON_OPERATOR_EQUALS = 1;
   */
  EQUALS = 1,

  /**
   * > < >= <= only applies to number values.
   *
   * @generated from enum value: COMPARISON_OPERATOR_LESS_THAN = 2;
   */
  LESS_THAN = 2,

  /**
   * @generated from enum value: COMPARISON_OPERATOR_LESS_THAN_OR_EQUALS = 3;
   */
  LESS_THAN_OR_EQUALS = 3,

  /**
   * @generated from enum value: COMPARISON_OPERATOR_GREATER_THAN = 4;
   */
  GREATER_THAN = 4,

  /**
   * @generated from enum value: COMPARISON_OPERATOR_GREATER_THAN_OR_EQUALS = 5;
   */
  GREATER_THAN_OR_EQUALS = 5,

  /**
   * Contained within only applies to list values. Elements
   * of the list must be primitive (i.e. number, string or bool)
   *
   * @generated from enum value: COMPARISON_OPERATOR_CONTAINED_WITHIN = 6;
   */
  CONTAINED_WITHIN = 6,

  /**
   * Starts with and ends with only apply to string values.
   *
   * @generated from enum value: COMPARISON_OPERATOR_STARTS_WITH = 7;
   */
  STARTS_WITH = 7,

  /**
   * @generated from enum value: COMPARISON_OPERATOR_ENDS_WITH = 8;
   */
  ENDS_WITH = 8,

  /**
   * Contains only applies to string values, and for now is strict equality.
   * If we support things like regex or case insensitive matches, they will
   * be separate operators.
   *
   * @generated from enum value: COMPARISON_OPERATOR_CONTAINS = 9;
   */
  CONTAINS = 9,

  /**
   * Present is the only operator that doesn't require a comparison value.
   *
   * @generated from enum value: COMPARISON_OPERATOR_PRESENT = 10;
   */
  PRESENT = 10,

  /**
   * != only applies to number, string and bool values.
   *
   * @generated from enum value: COMPARISON_OPERATOR_NOT_EQUALS = 11;
   */
  NOT_EQUALS = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(ComparisonOperator)
proto3.util.setEnumType(ComparisonOperator, "lekko.rules.v1beta3.ComparisonOperator", [
  { no: 0, name: "COMPARISON_OPERATOR_UNSPECIFIED" },
  { no: 1, name: "COMPARISON_OPERATOR_EQUALS" },
  { no: 2, name: "COMPARISON_OPERATOR_LESS_THAN" },
  { no: 3, name: "COMPARISON_OPERATOR_LESS_THAN_OR_EQUALS" },
  { no: 4, name: "COMPARISON_OPERATOR_GREATER_THAN" },
  { no: 5, name: "COMPARISON_OPERATOR_GREATER_THAN_OR_EQUALS" },
  { no: 6, name: "COMPARISON_OPERATOR_CONTAINED_WITHIN" },
  { no: 7, name: "COMPARISON_OPERATOR_STARTS_WITH" },
  { no: 8, name: "COMPARISON_OPERATOR_ENDS_WITH" },
  { no: 9, name: "COMPARISON_OPERATOR_CONTAINS" },
  { no: 10, name: "COMPARISON_OPERATOR_PRESENT" },
  { no: 11, name: "COMPARISON_OPERATOR_NOT_EQUALS" },
]);

/**
 * @generated from enum lekko.rules.v1beta3.LogicalOperator
 */
export enum LogicalOperator {
  /**
   * @generated from enum value: LOGICAL_OPERATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LOGICAL_OPERATOR_AND = 1;
   */
  AND = 1,

  /**
   * @generated from enum value: LOGICAL_OPERATOR_OR = 2;
   */
  OR = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LogicalOperator)
proto3.util.setEnumType(LogicalOperator, "lekko.rules.v1beta3.LogicalOperator", [
  { no: 0, name: "LOGICAL_OPERATOR_UNSPECIFIED" },
  { no: 1, name: "LOGICAL_OPERATOR_AND" },
  { no: 2, name: "LOGICAL_OPERATOR_OR" },
]);

/**
 * A Rule is a top level object that recursively defines an AST represented
 * by ruleslang. A rule is always one of 4 things:
 * 1. Atom -> This is a leaf node in the tree that returns true or false
 * 2. Not -> This negates the result of the underlying Rule.
 * 3. LogicalExpression -> This rule links at least two rules through an "and" or an "or".
 * 4. BoolConst -> true or false. This will be used for higher level short-circuits.
 * 5. CallExpression -> This rule is a function call that returns true or false.
 * Parentheses and other logical constructs can all be represented by the correct
 * construction of this rule tree.
 *
 * !(A && B && C) || D can be represented by LogExp ( Not ( LogExp ( Atom(A) && Atom(B) && Atom(C) )) || Atom(D))
 *
 * @generated from message lekko.rules.v1beta3.Rule
 */
export class Rule extends Message<Rule> {
  /**
   * @generated from oneof lekko.rules.v1beta3.Rule.rule
   */
  rule: {
    /**
     * @generated from field: lekko.rules.v1beta3.Atom atom = 1;
     */
    value: Atom;
    case: "atom";
  } | {
    /**
     * @generated from field: lekko.rules.v1beta3.Rule not = 2;
     */
    value: Rule;
    case: "not";
  } | {
    /**
     * @generated from field: lekko.rules.v1beta3.LogicalExpression logical_expression = 3;
     */
    value: LogicalExpression;
    case: "logicalExpression";
  } | {
    /**
     * @generated from field: bool bool_const = 4;
     */
    value: boolean;
    case: "boolConst";
  } | {
    /**
     * @generated from field: lekko.rules.v1beta3.CallExpression call_expression = 5;
     */
    value: CallExpression;
    case: "callExpression";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Comments right after the rule
   *
   * @generated from field: repeated string comments = 6;
   */
  comments: string[] = [];

  constructor(data?: PartialMessage<Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lekko.rules.v1beta3.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "atom", kind: "message", T: Atom, oneof: "rule" },
    { no: 2, name: "not", kind: "message", T: Rule, oneof: "rule" },
    { no: 3, name: "logical_expression", kind: "message", T: LogicalExpression, oneof: "rule" },
    { no: 4, name: "bool_const", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "rule" },
    { no: 5, name: "call_expression", kind: "message", T: CallExpression, oneof: "rule" },
    { no: 6, name: "comments", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule {
    return new Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJsonString(jsonString, options);
  }

  static equals(a: Rule | PlainMessage<Rule> | undefined, b: Rule | PlainMessage<Rule> | undefined): boolean {
    return proto3.util.equals(Rule, a, b);
  }
}

/**
 * LogicalExpression operator applies a logical operator like "and" or "or" to n rules.
 * They are evaluated in the order expressed by the repeated field.
 *
 * @generated from message lekko.rules.v1beta3.LogicalExpression
 */
export class LogicalExpression extends Message<LogicalExpression> {
  /**
   * @generated from field: repeated lekko.rules.v1beta3.Rule rules = 1;
   */
  rules: Rule[] = [];

  /**
   * @generated from field: lekko.rules.v1beta3.LogicalOperator logical_operator = 3;
   */
  logicalOperator = LogicalOperator.UNSPECIFIED;

  constructor(data?: PartialMessage<LogicalExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lekko.rules.v1beta3.LogicalExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rules", kind: "message", T: Rule, repeated: true },
    { no: 3, name: "logical_operator", kind: "enum", T: proto3.getEnumType(LogicalOperator) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogicalExpression {
    return new LogicalExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogicalExpression {
    return new LogicalExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogicalExpression {
    return new LogicalExpression().fromJsonString(jsonString, options);
  }

  static equals(a: LogicalExpression | PlainMessage<LogicalExpression> | undefined, b: LogicalExpression | PlainMessage<LogicalExpression> | undefined): boolean {
    return proto3.util.equals(LogicalExpression, a, b);
  }
}

/**
 * An atom is a fragment of ruleslang that can result in a true or false.
 * An atom always has a comparison operator and a context key, and can optionally
 * have a comparison value.
 *
 * @generated from message lekko.rules.v1beta3.Atom
 */
export class Atom extends Message<Atom> {
  /**
   * @generated from field: string context_key = 1;
   */
  contextKey = "";

  /**
   * For the "PRESENT" operator, the comparison value should be null.
   *
   * @generated from field: google.protobuf.Value comparison_value = 2;
   */
  comparisonValue?: Value;

  /**
   * For operators, context is on the left, comparison value on the right.
   *
   * @generated from field: lekko.rules.v1beta3.ComparisonOperator comparison_operator = 3;
   */
  comparisonOperator = ComparisonOperator.UNSPECIFIED;

  constructor(data?: PartialMessage<Atom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lekko.rules.v1beta3.Atom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "context_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "comparison_value", kind: "message", T: Value },
    { no: 3, name: "comparison_operator", kind: "enum", T: proto3.getEnumType(ComparisonOperator) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Atom {
    return new Atom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Atom {
    return new Atom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Atom {
    return new Atom().fromJsonString(jsonString, options);
  }

  static equals(a: Atom | PlainMessage<Atom> | undefined, b: Atom | PlainMessage<Atom> | undefined): boolean {
    return proto3.util.equals(Atom, a, b);
  }
}

/**
 * CallExpression represents a function call, e.g. f(a, b, c).
 * Each function has a specific signature, so a CallExpression is
 * expressed as one of the different supported functions.
 *
 * Example signature
 * message Example {
 *   uint32 x = 1;
 *   string y = 2;
 * }
 *
 * @generated from message lekko.rules.v1beta3.CallExpression
 */
export class CallExpression extends Message<CallExpression> {
  /**
   * @generated from oneof lekko.rules.v1beta3.CallExpression.function
   */
  function: {
    /**
     * @generated from field: lekko.rules.v1beta3.CallExpression.Bucket bucket = 1;
     */
    value: CallExpression_Bucket;
    case: "bucket";
  } | {
    /**
     * @generated from field: lekko.rules.v1beta3.CallExpression.EvaluateTo evaluate_to = 2;
     */
    value: CallExpression_EvaluateTo;
    case: "evaluateTo";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CallExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lekko.rules.v1beta3.CallExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket", kind: "message", T: CallExpression_Bucket, oneof: "function" },
    { no: 2, name: "evaluate_to", kind: "message", T: CallExpression_EvaluateTo, oneof: "function" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallExpression {
    return new CallExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallExpression {
    return new CallExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallExpression {
    return new CallExpression().fromJsonString(jsonString, options);
  }

  static equals(a: CallExpression | PlainMessage<CallExpression> | undefined, b: CallExpression | PlainMessage<CallExpression> | undefined): boolean {
    return proto3.util.equals(CallExpression, a, b);
  }
}

/**
 * Bucketing function for percentage-based context evaluation
 *
 * @generated from message lekko.rules.v1beta3.CallExpression.Bucket
 */
export class CallExpression_Bucket extends Message<CallExpression_Bucket> {
  /**
   * @generated from field: string context_key = 1;
   */
  contextKey = "";

  /**
   * Threshold for dividing buckets.
   * Stored as an integer in the range [0, 100000] instead of a double
   * to avoid potential precision issues while supporting up to 3
   * decimal places to users.
   * e.g. threshold = 75125 -> 75.125%
   *
   * @generated from field: uint32 threshold = 2;
   */
  threshold = 0;

  constructor(data?: PartialMessage<CallExpression_Bucket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lekko.rules.v1beta3.CallExpression.Bucket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "context_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "threshold", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallExpression_Bucket {
    return new CallExpression_Bucket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallExpression_Bucket {
    return new CallExpression_Bucket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallExpression_Bucket {
    return new CallExpression_Bucket().fromJsonString(jsonString, options);
  }

  static equals(a: CallExpression_Bucket | PlainMessage<CallExpression_Bucket> | undefined, b: CallExpression_Bucket | PlainMessage<CallExpression_Bucket> | undefined): boolean {
    return proto3.util.equals(CallExpression_Bucket, a, b);
  }
}

/**
 * Function for nested config evaluation
 * Returns `true` if the config with `config_name` evaluates to `config_value`
 *
 * @generated from message lekko.rules.v1beta3.CallExpression.EvaluateTo
 */
export class CallExpression_EvaluateTo extends Message<CallExpression_EvaluateTo> {
  /**
   * @generated from field: string config_name = 1;
   */
  configName = "";

  /**
   * @generated from field: google.protobuf.Value config_value = 2;
   */
  configValue?: Value;

  constructor(data?: PartialMessage<CallExpression_EvaluateTo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lekko.rules.v1beta3.CallExpression.EvaluateTo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config_value", kind: "message", T: Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallExpression_EvaluateTo {
    return new CallExpression_EvaluateTo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallExpression_EvaluateTo {
    return new CallExpression_EvaluateTo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallExpression_EvaluateTo {
    return new CallExpression_EvaluateTo().fromJsonString(jsonString, options);
  }

  static equals(a: CallExpression_EvaluateTo | PlainMessage<CallExpression_EvaluateTo> | undefined, b: CallExpression_EvaluateTo | PlainMessage<CallExpression_EvaluateTo> | undefined): boolean {
    return proto3.util.equals(CallExpression_EvaluateTo, a, b);
  }
}

/**
 * @generated from message lekko.rules.v1beta3.ConfigCall
 */
export class ConfigCall extends Message<ConfigCall> {
  /**
   * @generated from field: string type_url = 1;
   */
  typeUrl = "";

  /**
   * @generated from field: string namespace = 2;
   */
  namespace = "";

  /**
   * @generated from field: string key = 3;
   */
  key = "";

  /**
   * @generated from field: uint64 field_number = 4;
   */
  fieldNumber = protoInt64.zero;

  constructor(data?: PartialMessage<ConfigCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lekko.rules.v1beta3.ConfigCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "field_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigCall {
    return new ConfigCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigCall {
    return new ConfigCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigCall {
    return new ConfigCall().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigCall | PlainMessage<ConfigCall> | undefined, b: ConfigCall | PlainMessage<ConfigCall> | undefined): boolean {
    return proto3.util.equals(ConfigCall, a, b);
  }
}

