// Copyright 2022 Lekko Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.7.2 with parameter "target=ts,import_extension=none"
// @generated from file lekko/feature/v1beta1/static.proto (package lekko.feature.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf"
import { Message, proto3, Struct } from "@bufbuild/protobuf"
import { Feature, FeatureType } from "./feature_pb"

/**
 * Represents a statically parsed feature.
 * This model is meant to contain all sorts of data that is available
 * to us via inspecting the starlark file, but may not be available
 * post-compilation. E.g. what import statements were defined, and what
 * comments were written surrounding certain expressions.
 * The goal is to add to this model any information we wish to surface
 * to the UI or that is needed for static mutation of a feature.
 *
 * @generated from message lekko.feature.v1beta1.StaticFeature
 */
export class StaticFeature extends Message<StaticFeature> {
  /**
   * @generated from field: string key = 1;
   */
  key = ""

  /**
   * @generated from field: lekko.feature.v1beta1.FeatureType type = 2;
   */
  type = FeatureType.UNSPECIFIED

  /**
   * @generated from field: repeated lekko.feature.v1beta1.ImportStatement imports = 3;
   */
  imports: ImportStatement[] = []

  /**
   * Experimental protobuf message that is a representation
   * of the statically parsed starlark AST.
   *
   * @generated from field: lekko.feature.v1beta1.FeatureStruct feature = 4;
   */
  feature?: FeatureStruct

  /**
   * For backwards compatibility. Eventually, the materialized
   * model will be deprecated in favor of a statically parsed model
   *
   * @generated from field: lekko.feature.v1beta1.Feature feature_old = 5;
   */
  featureOld?: Feature

  constructor(data?: PartialMessage<StaticFeature>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.StaticFeature"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(FeatureType) },
    {
      no: 3,
      name: "imports",
      kind: "message",
      T: ImportStatement,
      repeated: true,
    },
    { no: 4, name: "feature", kind: "message", T: FeatureStruct },
    { no: 5, name: "feature_old", kind: "message", T: Feature },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): StaticFeature {
    return new StaticFeature().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): StaticFeature {
    return new StaticFeature().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): StaticFeature {
    return new StaticFeature().fromJsonString(jsonString, options)
  }

  static equals(
    a: StaticFeature | PlainMessage<StaticFeature> | undefined,
    b: StaticFeature | PlainMessage<StaticFeature> | undefined,
  ): boolean {
    return proto3.util.equals(StaticFeature, a, b)
  }
}

/**
 * Represents everything stored in the config struct in starlark.
 * i.e. `Config(...)`
 *
 * @generated from message lekko.feature.v1beta1.FeatureStruct
 */
export class FeatureStruct extends Message<FeatureStruct> {
  /**
   * @generated from field: lekko.feature.v1beta1.StarMeta meta = 1;
   */
  meta?: StarMeta

  /**
   * @generated from field: string description = 2;
   */
  description = ""

  /**
   * @generated from field: lekko.feature.v1beta1.StarExpr default = 3;
   */
  default?: StarExpr

  /**
   * @generated from field: lekko.feature.v1beta1.Rules rules = 4;
   */
  rules?: Rules

  /**
   * @generated from field: google.protobuf.Struct metadata = 7;
   */
  metadata?: Struct

  constructor(data?: PartialMessage<FeatureStruct>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.FeatureStruct"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: StarMeta },
    {
      no: 2,
      name: "description",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 3, name: "default", kind: "message", T: StarExpr },
    { no: 4, name: "rules", kind: "message", T: Rules },
    { no: 7, name: "metadata", kind: "message", T: Struct },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): FeatureStruct {
    return new FeatureStruct().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): FeatureStruct {
    return new FeatureStruct().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): FeatureStruct {
    return new FeatureStruct().fromJsonString(jsonString, options)
  }

  static equals(
    a: FeatureStruct | PlainMessage<FeatureStruct> | undefined,
    b: FeatureStruct | PlainMessage<FeatureStruct> | undefined,
  ): boolean {
    return proto3.util.equals(FeatureStruct, a, b)
  }
}

/**
 * @generated from message lekko.feature.v1beta1.Rules
 */
export class Rules extends Message<Rules> {
  /**
   * @generated from field: lekko.feature.v1beta1.StarMeta meta = 1;
   */
  meta?: StarMeta

  /**
   * @generated from field: repeated lekko.feature.v1beta1.Rule rules = 2;
   */
  rules: Rule[] = []

  constructor(data?: PartialMessage<Rules>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.Rules"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: StarMeta },
    { no: 2, name: "rules", kind: "message", T: Rule, repeated: true },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Rules {
    return new Rules().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): Rules {
    return new Rules().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Rules {
    return new Rules().fromJsonString(jsonString, options)
  }

  static equals(
    a: Rules | PlainMessage<Rules> | undefined,
    b: Rules | PlainMessage<Rules> | undefined,
  ): boolean {
    return proto3.util.equals(Rules, a, b)
  }
}

/**
 * @generated from message lekko.feature.v1beta1.Rule
 */
export class Rule extends Message<Rule> {
  /**
   * @generated from field: lekko.feature.v1beta1.StarMeta meta = 1;
   */
  meta?: StarMeta

  /**
   * @generated from field: string condition = 2;
   */
  condition = ""

  /**
   * @generated from field: lekko.feature.v1beta1.StarExpr value = 3;
   */
  value?: StarExpr

  constructor(data?: PartialMessage<Rule>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.Rule"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: StarMeta },
    { no: 2, name: "condition", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "message", T: StarExpr },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Rule {
    return new Rule().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): Rule {
    return new Rule().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Rule {
    return new Rule().fromJsonString(jsonString, options)
  }

  static equals(
    a: Rule | PlainMessage<Rule> | undefined,
    b: Rule | PlainMessage<Rule> | undefined,
  ): boolean {
    return proto3.util.equals(Rule, a, b)
  }
}

/**
 * An assignment expression in starlark, e.g. `x = 1`.
 *
 * @generated from message lekko.feature.v1beta1.ImportStatement
 */
export class ImportStatement extends Message<ImportStatement> {
  /**
   * @generated from field: lekko.feature.v1beta1.StarMeta meta = 1;
   */
  meta?: StarMeta

  /**
   * the variable that the import is assigned to
   *
   * @generated from field: lekko.feature.v1beta1.IdentExpr lhs = 2;
   */
  lhs?: IdentExpr

  /**
   * e.g. `=`
   *
   * @generated from field: string operator = 3;
   */
  operator = ""

  /**
   * Line break between operator and RHS
   *
   * @generated from field: bool line_break = 4;
   */
  lineBreak = false

  /**
   * @generated from field: lekko.feature.v1beta1.ImportExpr rhs = 5;
   */
  rhs?: ImportExpr

  constructor(data?: PartialMessage<ImportStatement>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.ImportStatement"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: StarMeta },
    { no: 2, name: "lhs", kind: "message", T: IdentExpr },
    { no: 3, name: "operator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "line_break", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "rhs", kind: "message", T: ImportExpr },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ImportStatement {
    return new ImportStatement().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ImportStatement {
    return new ImportStatement().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ImportStatement {
    return new ImportStatement().fromJsonString(jsonString, options)
  }

  static equals(
    a: ImportStatement | PlainMessage<ImportStatement> | undefined,
    b: ImportStatement | PlainMessage<ImportStatement> | undefined,
  ): boolean {
    return proto3.util.equals(ImportStatement, a, b)
  }
}

/**
 * an import expression, e.g. `proto.package("google.protobuf")`
 *
 * @generated from message lekko.feature.v1beta1.ImportExpr
 */
export class ImportExpr extends Message<ImportExpr> {
  /**
   * @generated from field: lekko.feature.v1beta1.StarMeta meta = 1;
   */
  meta?: StarMeta

  /**
   * @generated from field: lekko.feature.v1beta1.DotExpr dot = 2;
   */
  dot?: DotExpr

  /**
   * @generated from field: repeated string args = 3;
   */
  args: string[] = []

  constructor(data?: PartialMessage<ImportExpr>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.ImportExpr"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: StarMeta },
    { no: 2, name: "dot", kind: "message", T: DotExpr },
    {
      no: 3,
      name: "args",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      repeated: true,
    },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ImportExpr {
    return new ImportExpr().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ImportExpr {
    return new ImportExpr().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ImportExpr {
    return new ImportExpr().fromJsonString(jsonString, options)
  }

  static equals(
    a: ImportExpr | PlainMessage<ImportExpr> | undefined,
    b: ImportExpr | PlainMessage<ImportExpr> | undefined,
  ): boolean {
    return proto3.util.equals(ImportExpr, a, b)
  }
}

/**
 * a dot expression, e.g. `proto.package`
 *
 * @generated from message lekko.feature.v1beta1.DotExpr
 */
export class DotExpr extends Message<DotExpr> {
  /**
   * @generated from field: lekko.feature.v1beta1.StarMeta meta = 1;
   */
  meta?: StarMeta

  /**
   * The token that appears before the dot in the dot expression, e.g. `proto`
   *
   * @generated from field: string x = 2;
   */
  x = ""

  /**
   * The token that appears after the dot in the dot expression, e.g. `package`
   *
   * @generated from field: string name = 3;
   */
  name = ""

  constructor(data?: PartialMessage<DotExpr>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.DotExpr"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: StarMeta },
    { no: 2, name: "x", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): DotExpr {
    return new DotExpr().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): DotExpr {
    return new DotExpr().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): DotExpr {
    return new DotExpr().fromJsonString(jsonString, options)
  }

  static equals(
    a: DotExpr | PlainMessage<DotExpr> | undefined,
    b: DotExpr | PlainMessage<DotExpr> | undefined,
  ): boolean {
    return proto3.util.equals(DotExpr, a, b)
  }
}

/**
 * A single starlark expression. May not be fully decomposed.
 * Stores the string representation of the expression in the metadata.
 *
 * @generated from message lekko.feature.v1beta1.StarExpr
 */
export class StarExpr extends Message<StarExpr> {
  /**
   * @generated from field: lekko.feature.v1beta1.StarMeta meta = 1;
   */
  meta?: StarMeta

  /**
   * @generated from field: string expression = 2;
   */
  expression = ""

  constructor(data?: PartialMessage<StarExpr>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.StarExpr"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: StarMeta },
    { no: 2, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): StarExpr {
    return new StarExpr().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): StarExpr {
    return new StarExpr().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): StarExpr {
    return new StarExpr().fromJsonString(jsonString, options)
  }

  static equals(
    a: StarExpr | PlainMessage<StarExpr> | undefined,
    b: StarExpr | PlainMessage<StarExpr> | undefined,
  ): boolean {
    return proto3.util.equals(StarExpr, a, b)
  }
}

/**
 * A single token in starlark. E.g. True, False, or a variable name.
 *
 * @generated from message lekko.feature.v1beta1.IdentExpr
 */
export class IdentExpr extends Message<IdentExpr> {
  /**
   * @generated from field: lekko.feature.v1beta1.StarMeta meta = 1;
   */
  meta?: StarMeta

  /**
   * @generated from field: string token = 2;
   */
  token = ""

  constructor(data?: PartialMessage<IdentExpr>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.IdentExpr"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: StarMeta },
    { no: 2, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): IdentExpr {
    return new IdentExpr().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): IdentExpr {
    return new IdentExpr().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): IdentExpr {
    return new IdentExpr().fromJsonString(jsonString, options)
  }

  static equals(
    a: IdentExpr | PlainMessage<IdentExpr> | undefined,
    b: IdentExpr | PlainMessage<IdentExpr> | undefined,
  ): boolean {
    return proto3.util.equals(IdentExpr, a, b)
  }
}

/**
 * Metadata commonly associated with any starlark expression
 *
 * @generated from message lekko.feature.v1beta1.StarMeta
 */
export class StarMeta extends Message<StarMeta> {
  /**
   * @generated from field: lekko.feature.v1beta1.Comments comments = 1;
   */
  comments?: Comments

  /**
   * @generated from field: bool multiline = 2;
   */
  multiline = false

  constructor(data?: PartialMessage<StarMeta>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.StarMeta"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "comments", kind: "message", T: Comments },
    { no: 2, name: "multiline", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): StarMeta {
    return new StarMeta().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): StarMeta {
    return new StarMeta().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): StarMeta {
    return new StarMeta().fromJsonString(jsonString, options)
  }

  static equals(
    a: StarMeta | PlainMessage<StarMeta> | undefined,
    b: StarMeta | PlainMessage<StarMeta> | undefined,
  ): boolean {
    return proto3.util.equals(StarMeta, a, b)
  }
}

/**
 * @generated from message lekko.feature.v1beta1.Comments
 */
export class Comments extends Message<Comments> {
  /**
   * @generated from field: repeated lekko.feature.v1beta1.Comment before = 1;
   */
  before: Comment[] = []

  /**
   * @generated from field: repeated lekko.feature.v1beta1.Comment suffix = 2;
   */
  suffix: Comment[] = []

  /**
   * @generated from field: repeated lekko.feature.v1beta1.Comment after = 3;
   */
  after: Comment[] = []

  constructor(data?: PartialMessage<Comments>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.Comments"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "before", kind: "message", T: Comment, repeated: true },
    { no: 2, name: "suffix", kind: "message", T: Comment, repeated: true },
    { no: 3, name: "after", kind: "message", T: Comment, repeated: true },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Comments {
    return new Comments().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): Comments {
    return new Comments().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Comments {
    return new Comments().fromJsonString(jsonString, options)
  }

  static equals(
    a: Comments | PlainMessage<Comments> | undefined,
    b: Comments | PlainMessage<Comments> | undefined,
  ): boolean {
    return proto3.util.equals(Comments, a, b)
  }
}

/**
 * @generated from message lekko.feature.v1beta1.Comment
 */
export class Comment extends Message<Comment> {
  /**
   * @generated from field: string token = 1;
   */
  token = ""

  constructor(data?: PartialMessage<Comment>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.feature.v1beta1.Comment"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Comment {
    return new Comment().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): Comment {
    return new Comment().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Comment {
    return new Comment().fromJsonString(jsonString, options)
  }

  static equals(
    a: Comment | PlainMessage<Comment> | undefined,
    b: Comment | PlainMessage<Comment> | undefined,
  ): boolean {
    return proto3.util.equals(Comment, a, b)
  }
}
