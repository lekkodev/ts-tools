// Copyright 2022 Lekko Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.7.2 with parameter "target=ts,import_extension=none"
// @generated from file lekko/rules/v1beta2/rules.proto (package lekko.rules.v1beta2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf"
import { Message, proto3, Value } from "@bufbuild/protobuf"

/**
 * @generated from enum lekko.rules.v1beta2.ComparisonOperator
 * @deprecated
 */
export enum ComparisonOperator {
  /**
   * @generated from enum value: COMPARISON_OPERATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * == only applies to number, string and bool values.
   *
   * @generated from enum value: COMPARISON_OPERATOR_EQUALS = 1;
   */
  EQUALS = 1,

  /**
   * > < >= <= only applies to number values.
   *
   * @generated from enum value: COMPARISON_OPERATOR_LESS_THAN = 2;
   */
  LESS_THAN = 2,

  /**
   * @generated from enum value: COMPARISON_OPERATOR_LESS_THAN_OR_EQUALS = 3;
   */
  LESS_THAN_OR_EQUALS = 3,

  /**
   * @generated from enum value: COMPARISON_OPERATOR_GREATER_THAN = 4;
   */
  GREATER_THAN = 4,

  /**
   * @generated from enum value: COMPARISON_OPERATOR_GREATER_THAN_OR_EQUALS = 5;
   */
  GREATER_THAN_OR_EQUALS = 5,

  /**
   * Contained within only applies to list values. Elements
   * of the list must be primitive (i.e. number, string or bool)
   *
   * @generated from enum value: COMPARISON_OPERATOR_CONTAINED_WITHIN = 6;
   */
  CONTAINED_WITHIN = 6,

  /**
   * Starts with and ends with only apply to string values.
   *
   * @generated from enum value: COMPARISON_OPERATOR_STARTS_WITH = 7;
   */
  STARTS_WITH = 7,

  /**
   * @generated from enum value: COMPARISON_OPERATOR_ENDS_WITH = 8;
   */
  ENDS_WITH = 8,

  /**
   * Contains only applies to string values, and for now is strict equality.
   * If we support things like regex or case insensitive matches, they will
   * be separate operators.
   *
   * @generated from enum value: COMPARISON_OPERATOR_CONTAINS = 9;
   */
  CONTAINS = 9,

  /**
   * Present is the only operator that doesn't require a comparison value.
   *
   * @generated from enum value: COMPARISON_OPERATOR_PRESENT = 10;
   */
  PRESENT = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(ComparisonOperator)
proto3.util.setEnumType(
  ComparisonOperator,
  "lekko.rules.v1beta2.ComparisonOperator",
  [
    { no: 0, name: "COMPARISON_OPERATOR_UNSPECIFIED" },
    { no: 1, name: "COMPARISON_OPERATOR_EQUALS" },
    { no: 2, name: "COMPARISON_OPERATOR_LESS_THAN" },
    { no: 3, name: "COMPARISON_OPERATOR_LESS_THAN_OR_EQUALS" },
    { no: 4, name: "COMPARISON_OPERATOR_GREATER_THAN" },
    { no: 5, name: "COMPARISON_OPERATOR_GREATER_THAN_OR_EQUALS" },
    { no: 6, name: "COMPARISON_OPERATOR_CONTAINED_WITHIN" },
    { no: 7, name: "COMPARISON_OPERATOR_STARTS_WITH" },
    { no: 8, name: "COMPARISON_OPERATOR_ENDS_WITH" },
    { no: 9, name: "COMPARISON_OPERATOR_CONTAINS" },
    { no: 10, name: "COMPARISON_OPERATOR_PRESENT" },
  ],
)

/**
 * @generated from enum lekko.rules.v1beta2.LogicalOperator
 * @deprecated
 */
export enum LogicalOperator {
  /**
   * @generated from enum value: LOGICAL_OPERATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LOGICAL_OPERATOR_AND = 1;
   */
  AND = 1,

  /**
   * @generated from enum value: LOGICAL_OPERATOR_OR = 2;
   */
  OR = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LogicalOperator)
proto3.util.setEnumType(
  LogicalOperator,
  "lekko.rules.v1beta2.LogicalOperator",
  [
    { no: 0, name: "LOGICAL_OPERATOR_UNSPECIFIED" },
    { no: 1, name: "LOGICAL_OPERATOR_AND" },
    { no: 2, name: "LOGICAL_OPERATOR_OR" },
  ],
)

/**
 * A Rule is a top level object that recursively defines an AST represented
 * by ruleslang. A rule is always one of 4 things:
 * 1. Atom -> This is a leaf node in the tree that returns true or false
 * 2. Not -> This negates the result of the underlying Rule.
 * 3. LogicalExpression -> This rule links two rules through an "and" or an "or".
 * 4. BoolConst -> true or false. This will be used for higher level short-circuits.
 * Parenthases and other logical constructs can all be represented by the correct
 * construction of this rule tree.
 *
 * !(A && B && C) || D can be represented by LogExp ( Not ( LogExp ( LogExp ( Atom(A) && Atom(B) ) && Atom (C))) || Atom(D))
 *
 * @generated from message lekko.rules.v1beta2.Rule
 * @deprecated
 */
export class Rule extends Message<Rule> {
  /**
   * @generated from oneof lekko.rules.v1beta2.Rule.rule
   */
  rule:
    | {
        /**
         * @generated from field: lekko.rules.v1beta2.Atom atom = 1;
         */
        value: Atom
        case: "atom"
      }
    | {
        /**
         * @generated from field: lekko.rules.v1beta2.Rule not = 2;
         */
        value: Rule
        case: "not"
      }
    | {
        /**
         * @generated from field: lekko.rules.v1beta2.LogicalExpression logical_expression = 3;
         */
        value: LogicalExpression
        case: "logicalExpression"
      }
    | {
        /**
         * @generated from field: bool bool_const = 4;
         */
        value: boolean
        case: "boolConst"
      }
    | { case: undefined; value?: undefined } = { case: undefined }

  constructor(data?: PartialMessage<Rule>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.rules.v1beta2.Rule"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "atom", kind: "message", T: Atom, oneof: "rule" },
    { no: 2, name: "not", kind: "message", T: Rule, oneof: "rule" },
    {
      no: 3,
      name: "logical_expression",
      kind: "message",
      T: LogicalExpression,
      oneof: "rule",
    },
    {
      no: 4,
      name: "bool_const",
      kind: "scalar",
      T: 8 /* ScalarType.BOOL */,
      oneof: "rule",
    },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Rule {
    return new Rule().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): Rule {
    return new Rule().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Rule {
    return new Rule().fromJsonString(jsonString, options)
  }

  static equals(
    a: Rule | PlainMessage<Rule> | undefined,
    b: Rule | PlainMessage<Rule> | undefined,
  ): boolean {
    return proto3.util.equals(Rule, a, b)
  }
}

/**
 * LogicalExpression operator applies a logical operator like "and" or "or" to two rules.
 * They are evaluated in the order expressed by the field numbers and field names, with "first_rule" first.
 *
 * @generated from message lekko.rules.v1beta2.LogicalExpression
 * @deprecated
 */
export class LogicalExpression extends Message<LogicalExpression> {
  /**
   * @generated from field: lekko.rules.v1beta2.Rule first_rule = 1;
   */
  firstRule?: Rule

  /**
   * @generated from field: lekko.rules.v1beta2.Rule second_rule = 2;
   */
  secondRule?: Rule

  /**
   * @generated from field: lekko.rules.v1beta2.LogicalOperator logical_operator = 3;
   */
  logicalOperator = LogicalOperator.UNSPECIFIED

  constructor(data?: PartialMessage<LogicalExpression>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.rules.v1beta2.LogicalExpression"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "first_rule", kind: "message", T: Rule },
    { no: 2, name: "second_rule", kind: "message", T: Rule },
    {
      no: 3,
      name: "logical_operator",
      kind: "enum",
      T: proto3.getEnumType(LogicalOperator),
    },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): LogicalExpression {
    return new LogicalExpression().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): LogicalExpression {
    return new LogicalExpression().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): LogicalExpression {
    return new LogicalExpression().fromJsonString(jsonString, options)
  }

  static equals(
    a: LogicalExpression | PlainMessage<LogicalExpression> | undefined,
    b: LogicalExpression | PlainMessage<LogicalExpression> | undefined,
  ): boolean {
    return proto3.util.equals(LogicalExpression, a, b)
  }
}

/**
 * An atom is a fragment of ruleslang that can result in a true or false.
 * An atom always has a comparison operator and a context key, and can optionally
 * have a comparison value.
 *
 * @generated from message lekko.rules.v1beta2.Atom
 * @deprecated
 */
export class Atom extends Message<Atom> {
  /**
   * @generated from field: string context_key = 1;
   */
  contextKey = ""

  /**
   * For the "PRESENT" operator, the comparison value should be null.
   *
   * @generated from field: google.protobuf.Value comparison_value = 2;
   */
  comparisonValue?: Value

  /**
   * For operators, context is on the left, comparison value on the right.
   *
   * @generated from field: lekko.rules.v1beta2.ComparisonOperator comparison_operator = 3;
   */
  comparisonOperator = ComparisonOperator.UNSPECIFIED

  constructor(data?: PartialMessage<Atom>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "lekko.rules.v1beta2.Atom"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "context_key",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 2, name: "comparison_value", kind: "message", T: Value },
    {
      no: 3,
      name: "comparison_operator",
      kind: "enum",
      T: proto3.getEnumType(ComparisonOperator),
    },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Atom {
    return new Atom().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): Atom {
    return new Atom().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Atom {
    return new Atom().fromJsonString(jsonString, options)
  }

  static equals(
    a: Atom | PlainMessage<Atom> | undefined,
    b: Atom | PlainMessage<Atom> | undefined,
  ): boolean {
    return proto3.util.equals(Atom, a, b)
  }
}
